#<C++ Primer Plus>
[宏与内联函数]
宏:#define square(x) x*x
1.不能传递如1+2的参数;
2.自增运算会进行两次;
所以c++用内联函数替代;
[引用]
int &a = b;
a的地址和值与b相同,且a一直引用b,不能被改变;
按引用传递,可以改变参数的值,参数和变量共享同一地址和值,不会创建新的变量;
const int &a;a为常量引用,不可以改变a的值;
函数返回值将会把值复制到临时存储单元中，返回引用返回的是变量值本身
[临时变量]
1.不是左值变量
2.变量类型不正确
编译器会创建临时变量,创建临时变量不会改变变量的值
[函数模板]
格式:函数声明 template <typename T>  函数原型
函数定义:template <typename T>  函数原型 函数定义
模板局限性:无法对泛型表示的结构,数组进行加减操作;
显示具体化:使用具体类型代替泛型,比函数模板优先调用;template <>函数<> ();
[重载解析]
1.创建候选函数列表
2.创建可行函数列表
3.确定最佳可行函数
[匹配的优先级]
1.完全匹配
2.提升转换:char-short-int，float-double
3.标准转换:int-char,long-double
4.自定义转换
[完全匹配]
1.函数优先与非const指针和引用参数匹配
2.函数原型中const与非const存在区别仅限于指针和引用
[decltype]
decltype(x)y:使y和x的类型相同;
[auto]
template <class T1,class T2>auto foo(T1,T2)->decltype(x+y)
使用泛型作为参数，通过auto使用decltype确定返回类型
[多文件]
1.分类管理代码
2.编译时只用编译有改动的代码
[头文件]
#ifndef #define #endif:头文件复用时防止重编译
[存储持续性]
自动存储持续性：函数定义内声明的变量,存在于函数调用期间
静态存储持续性：函数定义外定义的变量，程序运行时
动态存储持续性：new分配的内存，程序运行时存在堆上
新定义的局部变量会隐藏旧的变量;
[栈]
使用指向栈顶的指针传递变量，函数创建变量时将变量放在指针指向
的位置，函数结束执行时，栈顶指针又会回到函数执行之前的位置，函数中
定义的变量仍然存在，但是会被新创建的变量覆盖
[静态变量初始化]
零初始化->常量初始化->动态初始化(函数被链接程序被执行后)
[extern]
引用声明关键字，不会分配内存
[单定义规则]
变量只能被单次定义，在一个文件定义的变量，另外一个文件不可以重复定义
在文件中定义变量时用static修饰，可以防止变量重定义;
[cin.get]
1.不会读取换行符，最多读取arg2 - 1个字符
2.如果读取到空行，返回false
3.连续读取时，需要剔除换行符和多余的字符
[constt]
1.代码块中定义const变量，意味着该常量只能在该代码块中使用
2.头文件中使用const变量，该变量具有内部链接性
[内联函数]
1.内联函数可以被重复定义
2.但是重新定义的内联函数的定义必须相同
即内联函数可以在头文件中定义
[动态内存]
初始化:new 类型 (初始值) | {初始值};
定位:new (地址) 类型 =>
char buf[10]; new (buf) int[2],从buf分配2个int的内存;
delete释放堆上的内存;定位运算分配的内存不能用delete删除;
[名称空间]
作用域:变量对程序可见的范围;
using namespace 名称空间:声明名称;
using 名称空间::变量:定义变量;
::作用域解析运算符,默认解析全局变量,可以解析变量或函数的作用域;
未命名的名称空间声明的变量具有内部链接性;
名称空间中声明的函数需要在名称空间中定义;
iostream.h没有使用名称空间;<iostream>使用了名称空间;
[类的初始化]
类会有默认构造函数;
创建对象时使用{参数...},可将参数传给构造函数，实现与数组相同的初始化方式;
[const类]
const类调用的函数申明时需要用const关键字,<返回值 类::函数() const>;
[this指针]
this指针指向用来调用成员函数的对象;
this指向对象地址;*this指向对象的值;
[<<]无法用于double或float型数据;
[作用域内枚举]
enum class:short {};枚举的作用域即为内部;成员的底层类型为short;
常规枚举可赋值整型;作用域内枚举不可,需要强制转换;
<使用类>
[返回引用]
1.返回引用,返回的是变量本身;
2.返回变量,返回的是变量副本;
[重载运算符]
operator+:声明重载运算符,对象使用+时自动调用
非成员函数:operator *(arg1,arg2) = arg1 * arg2;
友元函数:可以访问私有成员变量的函数;
[类的自动转换]
1.定义构造函数,将值赋予对象,将调用构造函数
2.explicit将关闭默认转换,关闭以后可以强制转换
<类和动态内存分配>
类在声明中不会分配内存;
[复制构造函数]
复制构造函数用于将一个对象复制到新创建的对象中;
原型:classname (const classname &);
按值传递会调用复制构造函数;
默认复制构造函数逐个复制非静态成员;
如果类中包含了使用new初始化的指针成员,应当定义
一个复制构造函数;
[赋值运算符]
赋值运算符的隐式实现也对成员进行逐个赋值;
1.分配之前使用delete释放数据;
2.避免将对象赋给自身;
3.返回一个调用对象的引用;
[定位new运算符]
创建对象指定内存地址:classname obj = new (地址) classname;
销毁对象:obj->析构函数;delete 地址;
<类继承>
派生类对象可以使用基类的方法;
派生类可以转换成基类;
多态:同一个方法的行为随上下文而异;
[virtual]
class & obj = OBJ;
obj.method;
如果没有使用virtual,程序将根据引用类型或指针类型选择方法;
如果使用了virtual,程序将根据引用或指针指向的对象的类型来选择方法.
虚析构方法:确保正确的析构函数序列被调用;
重新定义将隐藏虚方法;
[函数名联编]
静态联编:编译过程中进行联编;
动态联编:程序运行过程中进行联编;
[虚函数表]
class *pc = & son_class;
定义一个指向派生类的基类指针;
pc->func();
调用派生类的虚方法:
1.获悉pc->vtbl(虚函数表)的地址;
2.前往这个虚函数表;
3.获悉表中func的地址
4.前往地址执行func函数;
[抽象基类]
ABC:至少包含一个纯虚函数的接口,不能被具体成对象;
<代码重用>
[初始化列表]
初始化的顺序为被声明的顺序，而不是初始化列表中的顺序;
[私有继承]
基类的共有成员和保护成员都将成为派生类的私有成员;
如果成员是对象,则用对象.方法调用;
如果该类是私有继承,则用类名::方法调用;
强制类型转换可以访问私有继承的基类对象;
[保护继承]
基类的共有成员和保护成员都将成为派生类的保护成员
使用using声明来指出派生类可以使用特定的基类成员:
using std::valarray<double>::min;
[多重继承]
需要使用类型转换把基类设置为派生类中的基类地址的对象;
[虚基类]:基类的派生类的派生类继承派生类时只生成一个基类对象;
构造函数:第三代的类需要手动传递参数给基类;
调用基类方法:对象.类::方法;
[模板类]
头文件声明常量:
1.static const:const声明常量,static表示仅在文件内部使用
2.enum声明
模板类声明:
template <typename T> class 类名{};
模块类成员函数定义:
template <typename T> lei
模板默认值:
template <typename T1, typename T2 = int>;
模板具体化:
template classname<type>{},编译器将会优先匹配具体化模板;
[将模板用作参数]
template <template <typename T> class Thing> class Crab;
定义了一个模板类Crab,模板的参数是Thing,Thing的类型是模板,
改模板为template <typename T>接收一个泛型的参数;
<友元/异常和其他>
[嵌套类]
嵌套类声明的位置决定了类的作用域或可见性,类可见后,嵌套类成员的访问
权限由(公有,保护,私有)等访问控制规则确定.
[RTTI]运行阶段类型识别:
1.只适用于包含虚函数的类;
2.class *p = dynamic_cast<class *>(q):如果q的类型可以被安全地转换为p,
运算符将返回对象的地址,否正返回一个空指针.
3.class &p = dynamic_cast<class &>(q):引用在转换失败时会抛出异常;
4.typeid:对类型进行比较;typeid(class) == typeid(obj);
name()返回对象所属的类名称;
[const_cast]const_cast<typename> (express)
1.去掉变量声明的const;
2.指向的值不是const的才可以被修改;
[static_cast]static_cast<typename> (express)
当typename和express之间可以进行隐式转换是为合法的;
[reinterpret_cast]reinterpret_cast<typename> (express)
两个限制:1.不能将指针转换为更小的整形(char,short);
2.不能将函数指针转换为数据指针;
除此之外任意转换都能进行;
<模板类>
[auto_ptr类]:
在对象消失时自动调用析构函数释放堆而不是栈的内存;
赋值:auto_ptr<string> ps = p(auto_ptr<string>对象);ps将会获取对象的使用权,
p将不能使用原对象。
[shared_ptr类]
可以跟踪引用对象的智能指针数
[unique_ptr类]
赋值的时候,如果源是个临时右值,编译器允许赋值;否则会报错;
<输入输出和文件>
[endl]
endl刷新缓冲区,并插入一个换行符;“\n”输出换行符到缓冲区;
flush可以刷新缓冲区;
