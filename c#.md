<<c#从入门到精通>>
<数据类型>
[数据类型]
值类型:保存在栈上;
引用类型:保存在堆上;
[可空类型]
可空类型属于值类型,保存在栈上;
[类和结构]
类是引用类型,结构是值类型;
类支持继承;
[显示转换]
checked检查转换是否安全;
[运算符]
is:检查变量类型
as:在相互兼容的类型之间执行转换操作;
typeof:返回特定类型的System.Type对象;
[参数]
值类型会复制变量的值;引用类型使用变量本身;
ref:引用类型参数;
out:输出参数;
params:参数类型相同,数量可变;
命名参数:参数名:参数值传递即可;
foreach(xx in xx):遍历;
<类>
匿名类:var 类型 = new {};只读属性;
[属性成员]
格式:public 类型 成员
{set{} get{}};
[索引指示器]
格式:
访问修饰符 数据类型 this[索引类型 index]
{get{} set{}}
[字符串]
String.copy():重新生成字符串;
=:引用原来的字符串;
StringBuilder会在原来字符串上操作,不会分配新的空间;
<继承和派生>
[虚方法]
virtual声明虚方法;override重写基类的虚方法;
[抽象类]
只能被继承,不能被创建;
[密封类]
sealed定义密封类和密封方法,不能被派生类继承和重写;
<委托与事件>
[委托]
声明委托:权限修饰符 delegate 返回值 函数名(参数)
使用委托:定义委托对象,传递参数;
[比较器]
继承IComparer,重写方法Compare();

<<c#高级编程>>
<核心C#>
变量声明时必须被初始化;
[引用类型]
值类型存储在堆栈上,而引用类型存储在托管堆上;
new可以创建一个新的对象;
[string]
赋值时修改其中一个字符串,会创建一个全新的string对象;
@字符串:字符串中的字符不会解释为转义字符;
[Main()方法]
/main:告诉编译器程序的入口点;
[占位符]
{0:#.00}#表示有字符就输出,没字符不输出;
.00有字符就输出,没字符输出0;
[预处理指令]
#error+字符串:提示错误信息;
#warning+字符串:提示警告信息;
#line 12 core.cs改变文件名为core.cs,行号为12;
#pragma:用于还原和抑制编译的相关警告;
<对象和类型>
[结构和类的区别]
1.类是存储在堆上的引用类型,结构是存储在栈上的值类型;
2.类支持继承;
[给方法传递参数]
引用:方法得到的是这个变量;
值:方法得到的是变量副本;
ref:强制将值传送改为引用传送;
向方法传递参数前要初始化;
out:声明传递给方法的参数不用初始化;
命名参数:命名参数可以按照任意顺序传递;
可选参数:为方法的参数定义默认值,但必须是方法定义的最后的参数;
[属性]
声明: public int Age;
set:假定带有一个与属性相同的参数为value;
get:返回属性声明的类型;
可以为set或get设置访问权限,必须有一个具备属性的访问级别;
[静态构造函数]
加载类时由.NET运行库调用;
[调用其他构造函数]
1.this调用参数最匹配的构造函数;
2.base调用基类的构造函数;
[只读字段]
初始化赋值后变成常量;
[结构]
1.不允许定义无参数的构造函数;
2.System.ValueType可以作为结构的基类;
[部分类]
partial:可以嵌套部分类;
[静态类]
只包含静态的方法和属性;
[扩展方法]
public static void method(this class obj, int param)
this关键字表示需要扩展的类型;
<继承>
c#不支持多重继承,继承时没有public等限定符;
object是System.Object的假名;
[实现继承]
override:显示声明重写一个函数;
new:隐藏同名方法;
