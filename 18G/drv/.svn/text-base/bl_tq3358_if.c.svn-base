/*
 * bl_tq3358_if.c
 *
 *  Created on: 2015-12-8
 *      Author: Administrator
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/poll.h>
#include <linux/irq.h>
#include <asm/io.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>

#define DEVICE_NAME "BL_TQ3358_IF"

#define IF_CHECK_BASE 0x02000040
#define IF_CHECK_SIZE 0x7F

#define IF_CTRL_BASE  0x02000080    //ST1  中频控制基地址
#define IF_CTRL_SIZE  0x7F          //中频控制基地址长度
#define IF_PROC_BASE  0x02000100    //ST2  中频DSP基地址
#define IF_PROC_SIZE  0x7F          //中频DSP基地址长度
#define SF_PROC_BASE  0x02000180    //ST_SF  SF基地址
#define SF_PROC_SIZE  0x7F          //SF地址长度
#define DELAYTIME     10            //延时10ms
#define BUCLEN        8196  //2048  //BUC size
#define BUCLENSIZE    BUCLEN + 1

#define NDELAYTIME     200          //
static unsigned long sweepPoints = 501;
volatile u8* if_check_remapbuf;
volatile u8* if_ctrl_remapbuf;
volatile u8* if_proc_remapbuf;
volatile u8* if_ddc_remapbuf;

static unsigned long sampleid = 0; //0 ~ 5
static unsigned long data[BUCLENSIZE];

static unsigned char bytell = 0x00;
static unsigned char bytelh = 0x00;
static unsigned char bytehl = 0x00;
static unsigned char bytehh = 0x00;
static unsigned long dataFreq[1];
static unsigned int backlight = 0;
static int bucOffAddr = 0;

//ADF4360 操作指令
static int PA = 0;
#define SET_DATA_BIT(offset) do {iowrite8((PA=PA|0x01), if_ctrl_remapbuf + offset); wmb();} while (0)
#define CLR_DATA_BIT(offset) do {iowrite8((PA=PA&0xFE), if_ctrl_remapbuf + offset); wmb();} while (0)
#define SET_CLK_BIT(offset)	do {iowrite8((PA=PA|0x02), if_ctrl_remapbuf + offset); wmb();} while (0)
#define CLR_CLK_BIT(offset) do {iowrite8((PA=PA&0xFD), if_ctrl_remapbuf + offset); wmb();} while (0)
#define SET_CS_BIT(offset) do {iowrite8((PA=PA|0x04), if_ctrl_remapbuf + offset); wmb();} while (0)
#define CLR_CS_BIT(offset) do {iowrite8((PA=PA&0xFB), if_ctrl_remapbuf + offset); wmb();} while (0)

static void input_ADF4360(u32 data, u8 addr)
{
	int i;

	CLR_DATA_BIT(addr);
	CLR_CLK_BIT(addr);
	CLR_CS_BIT(addr);

	ndelay(20);

	for (i = 0; i < 24; i++)
	{
		if ((data & 0x800000) == 0)
			CLR_DATA_BIT(addr);
		else
			SET_DATA_BIT(addr);

		SET_CLK_BIT(addr);
		ndelay(25);
		CLR_CLK_BIT(addr);
		ndelay(25);

		data = data << 1;
	}

	ndelay(15);
	SET_CS_BIT(addr);
	ndelay(50);
	CLR_CS_BIT(addr);
}

static int readdpramvalue(void)
{
	int i;
	unsigned int aa = 0x00, bb = 0x00, cc = 0x00;

	switch (sampleid)
	{
		case 1: //normal
			for (i = 0 + bucOffAddr; i < sweepPoints + bucOffAddr; i++)
			{
				iowrite8(i >> 8, if_proc_remapbuf + 0x0d * 2); wmb();
				iowrite8(i & 0xff, if_proc_remapbuf + 0x09 * 2);	wmb();
				iowrite8(0, if_proc_remapbuf + 0x00 * 2);	wmb();

				if ((i % 2) == 0)
				{
					aa = ioread16(if_proc_remapbuf + 0x0a * 2);	rmb();
					bb = ioread16(if_proc_remapbuf + 0x0b * 2);	rmb();
				} else
				{
					aa = ioread16(if_proc_remapbuf + 0x0e * 2);	rmb();
					bb = ioread16(if_proc_remapbuf + 0x0f * 2); rmb();
				}

				data[i - bucOffAddr] = (aa + (bb << 16));
			}
			break;

		case 2: //neg peak
			for (i = 0 + bucOffAddr; i < sweepPoints + bucOffAddr; i++)
			{
				iowrite8(i >> 8, if_proc_remapbuf + 0x0d * 2); wmb();
				iowrite8(i & 0xff, if_proc_remapbuf + 0x09 * 2); wmb();
				iowrite8(0, if_proc_remapbuf + 0x00 * 2);	wmb();

				aa = ioread16(if_proc_remapbuf + 0x0e * 2);	rmb();
				bb = ioread16(if_proc_remapbuf + 0x0f * 2);	rmb();
				data[i - bucOffAddr] = (aa + (bb << 16));
			}
			break;

		case 3://sample
			for (i = 0 + bucOffAddr; i < sweepPoints + bucOffAddr; i++)
			{
				iowrite8(i >> 8, if_proc_remapbuf + 0x0d * 2); wmb();
				iowrite8(i & 0xff, if_proc_remapbuf + 0x09 * 2); wmb();
				iowrite8(0, if_proc_remapbuf + 0x00 * 2);	wmb();

				aa = ioread16(if_proc_remapbuf + 0x11 * 2);	rmb();
				bb = ioread16(if_proc_remapbuf + 0x12 * 2);	rmb();
				data[i - bucOffAddr] = (aa + (bb << 16));
			}
			break;

		case 0: //auto
		case 4: //pos peak
			for (i = 0 + bucOffAddr; i < sweepPoints + bucOffAddr; i++)
			{
				iowrite8(i >> 8, if_proc_remapbuf + 0x0d * 2);	wmb();
				iowrite8(i & 0xff, if_proc_remapbuf + 0x09 * 2); wmb();
				iowrite8(0, if_proc_remapbuf + 0x00 * 2);	wmb();

				aa = ioread16(if_proc_remapbuf + 0x0a * 2);	rmb();
				bb = ioread16(if_proc_remapbuf + 0x0b * 2);	rmb();
				data[i - bucOffAddr] = (aa + (bb << 16));
			}
			break;

		case 5: //瞬态检波
			for (i = 0 + bucOffAddr; i < sweepPoints + bucOffAddr; i++)
			{
				iowrite8(i >> 8, if_proc_remapbuf + 0x0d * 2);	wmb();
				iowrite8(i & 0xff, if_proc_remapbuf + 0x09 * 2); wmb();
				iowrite8(0, if_proc_remapbuf + 0x00 * 2);	wmb();

				aa = ioread16(if_proc_remapbuf + 0x0c * 2);	rmb();
				bb = ioread16(if_proc_remapbuf + 0x10 * 2);	rmb();
				data[i - bucOffAddr] = (aa + (bb << 16));
			}

			iowrite8(0x00, if_proc_remapbuf + 0x13 * 2);
			wmb(); //瞬态检波取完数据后，对中频地址19 空操作一次
			break;

		default:
			break;
	}

	return 0;
}

//DSP初始化
static int bl_ram_initialize(void)
{
	int SBUC;
	int SBUC_T_D;
	int SBUC_D;
	int BUC;
	int BUC_D;
	double SWEEP_T;
	double SBUC_T;
	int BW = 1, cic[13] = { 4, 15, 13, 21, 61, 201, 601, 2001, 6001, 250, 750, 2500, 6400 };
	long int cicclk;
	double r = (double) cic[BW];
	int shift = (int) r;
	int vbw = 0, vbw_fir[8] = { 0x5f, 0x3f, 0x2f, 0x1f, 0x0f, 0x0a, 0x05, 0x03 };

	SWEEP_T = 100.0; //ms 下发
	SBUC = 30; //   下发
	BUC = 500; //sigle bond固定/下发

	//CLK RST
	iowrite8(0x80, if_proc_remapbuf + 0x1f * 2);	wmb();
	iowrite8(0x00, if_proc_remapbuf + 0x1f * 2);	wmb();
	mdelay(DELAYTIME);

	//ADF4360 con, CLK_Gen
	input_ADF4360(0x05f9a4, 0x04);
	mdelay(1); //con rigster
	input_ADF4360(0x21681a, 0x04);
	mdelay(1); //N rigster
	input_ADF4360(0x100029, 0x04);
	mdelay(1); //R rigster
	mdelay(100);

	//CLK RST
	iowrite8(0x80, if_proc_remapbuf + 0x1f * 2);	wmb();
	iowrite8(0x00, if_proc_remapbuf + 0x1f * 2);	wmb();
	mdelay(DELAYTIME);

	//IF 通道选择
	iowrite8(0x01, if_proc_remapbuf + 0x1d * 2);	wmb(); //0x00-7.5K Crystal filter
	//IF Counter
	iowrite8(0x00, if_proc_remapbuf + 0x1c * 2);	wmb(); //0x00-count off,0x01-count on

	//SBUC BUC HSC GEN
	//SBUC_T
	SBUC_T = SWEEP_T / (SBUC * BUC); //ms
	SBUC_T_D = 65536.0 - (SBUC_T * 7500.0); //7.5MHz--CLK  SBUC_T_D = 65336, 0xff38

	iowrite8((u8)((SBUC_T_D >> 8) & 0xff), if_proc_remapbuf + 0x00 * 2);	wmb();
	mdelay(DELAYTIME);
	iowrite8((u8)(SBUC_T_D & 0xff), if_proc_remapbuf + 0x00 * 2);	wmb();
	mdelay(DELAYTIME);

	//SBUC_D
	SBUC_D = 65536 - SBUC;
	iowrite8((u8)((SBUC_D >> 8) & 0xff), if_proc_remapbuf + 0x1a * 2);	wmb();
	mdelay(DELAYTIME);
	iowrite8((u8)(SBUC_D & 0xff), if_proc_remapbuf + 0x1a * 2);	wmb();
	mdelay(DELAYTIME);

	//BUC
	BUC_D = 65536 - BUC;
	iowrite8((u8)((BUC_D >> 8) & 0xff), if_proc_remapbuf + 0x1b * 2);	wmb();
	mdelay(DELAYTIME);
	iowrite8((u8)(BUC_D & 0xff), if_proc_remapbuf + 0x1b * 2);	wmb();
	mdelay(DELAYTIME);

	// BUC sweep con
	iowrite8(0x08, if_proc_remapbuf + 0x1e * 2);	wmb(); //COUNT LOAD
	mdelay(DELAYTIME);
	iowrite8(0x00, if_proc_remapbuf + 0x1e * 2);	wmb();
	mdelay(DELAYTIME);
	iowrite8(0x40, if_proc_remapbuf + 0x1e * 2);	wmb(); //TRIG SWEEP
	mdelay(DELAYTIME);
	iowrite8(0x84, if_proc_remapbuf + 0x1e * 2);	wmb(); //0x84--AUTO SWEEP START   0x00--SWEEP STOP
	mdelay(DELAYTIME);

	r = 18;

	if (shift >= 63)
		shift = 63;
	iowrite8((u8) shift, if_proc_remapbuf + 0x06 * 2);	wmb(); //sent cic shift data

	// CIC CLK
	cicclk = (~cic[BW]) + 1; //cicclk = 0xa7
	iowrite8((u8)(cicclk & 0xff), if_proc_remapbuf + 0x03 * 2);	wmb(); // sent low eight data
	iowrite8((u8)((cicclk >> 8) & 0xff), if_proc_remapbuf + 0x04 * 2);	wmb(); // sent mid eight data
	iowrite8((u8)((cicclk >> 16) & 0xff), if_proc_remapbuf + 0x05 * 2);	wmb(); // sent high eight data

	//  CIC RST & LOAD
	iowrite8(0x01, if_proc_remapbuf + 0x07 * 2);	wmb();
	iowrite8(0x1e, if_proc_remapbuf + 0x07 * 2);	wmb();

	if (BW <= 1)
	{
		iowrite8(0x00, if_proc_remapbuf + 0x07 * 2); wmb(); //0x00-BW>=1MHz; 0x10-1k=<BW<1M; 0x20-BW<1k;
	} else if (BW <= 8)
	{
		iowrite8(0x10, if_proc_remapbuf + 0x07 * 2); wmb();
	} else
	{
		iowrite8(0x20, if_proc_remapbuf + 0x07 * 2); wmb();
	}

	// VBW CON
	iowrite8((u8) vbw_fir[vbw], if_proc_remapbuf + 0x08 * 2); wmb(); //outportb(0x608,vbw_fir[vbw]);
	iowrite8(0xff, if_proc_remapbuf + 0x15 * 2);	wmb(); //vbw data load
	iowrite8(0x00, if_proc_remapbuf + 0x15 * 2);	wmb(); //iowrite8(0x00, if_proc_remapbuf + 0x0f);

	readdpramvalue();

	return 0;
}

static int bl_ram_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
{
	if (count == 0) return -EINVAL;

	if (count == 4) //频率计数读数

	{
		bytell = ioread8(if_proc_remapbuf + 0x16 * 2); rmb();
		bytelh = ioread8(if_proc_remapbuf + 0x17 * 2); rmb();
		bytehl = ioread8(if_proc_remapbuf + 0x18 * 2); rmb();
		bytehh = ioread8(if_proc_remapbuf + 0x19 * 2); rmb();
		dataFreq[0] = bytell + (bytelh << 8) + (bytehl << 16) + (bytehh << 24);
		copy_to_user(buff, dataFreq, sizeof dataFreq);
	} else
	{
		readdpramvalue();

		if (count > sizeof data)
			copy_to_user(buff, data, sizeof data);
		else
			copy_to_user(buff, data, count);
	}

	return 0;
}

static int bl_ram_write(struct file *filp,const char __user *buff, size_t count, loff_t *offp)
{
	return 0;
}

static long bl_ram_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	if (cmd == 0xff)
	{
		if ((arg < 0) || (arg > 5))
			return 0;
		sampleid = arg;
	} else if (cmd == 0xfb)
	{
		//if(arg >= 101 && arg <= 1001)
		sweepPoints = arg;
	} else if (cmd == 0xfc)
	{
		bucOffAddr = arg;
	} else if (cmd == 0xf5)
	{
		backlight = arg;
		iowrite8(0x00, if_proc_remapbuf + 0x01 * 2); wmb();
		iowrite8(0x01, if_proc_remapbuf + 0x01 * 2); wmb();
		iowrite8(backlight, if_proc_remapbuf + 0x02 * 2); wmb();
	} else if (cmd == 0xfa)
	{
		iowrite8(arg, if_ddc_remapbuf + 0x00 * 2); wmb();
	} else if (cmd == 0xf9)
	{
		iowrite8(0x00, if_ddc_remapbuf + 0x01 * 2); wmb();
	} else if (cmd == 0xec)
	{
		int scValue = 0;
		scValue = ioread16(if_ctrl_remapbuf + 0x00 * 0); rmb();
		return scValue;
	} else
	{
		iowrite8(arg, if_proc_remapbuf + cmd * 2); wmb();
	}

	return 0;
}

static unsigned int bl_ram_poll(struct file *file, struct poll_table_struct *wait)
{
	return 0;
}

static struct file_operations dev_fops = {
		.owner = THIS_MODULE,
		.unlocked_ioctl = bl_ram_ioctl,
		.read = bl_ram_read,
		.write = bl_ram_write,
		.poll = bl_ram_poll,
};

static struct miscdevice misc = {
		.minor = MISC_DYNAMIC_MINOR,
		.name = DEVICE_NAME,
		.fops = &dev_fops,
};

static int __init dev_init(void)
{
	int ret;

	ret = misc_register(&misc);
	sampleid = 3;

	if_check_remapbuf = ioremap(IF_CHECK_BASE, IF_CHECK_SIZE);
	if_ctrl_remapbuf = ioremap(IF_CTRL_BASE, IF_CTRL_SIZE);
	if_proc_remapbuf = ioremap(IF_PROC_BASE, IF_PROC_SIZE);
	if_ddc_remapbuf = ioremap(SF_PROC_BASE, SF_PROC_SIZE);

	bl_ram_initialize();
	printk(DEVICE_NAME " initialized successed\n");

	return ret;
}

static void __exit dev_exit(void)
{
	iounmap((void *)if_check_remapbuf);
	iounmap((void *)if_ctrl_remapbuf);
	iounmap((void *)if_proc_remapbuf);
	iounmap((void *)if_ddc_remapbuf);
	misc_deregister(&misc);
}

module_init( dev_init);
module_exit( dev_exit);

MODULE_LICENSE("GPL");
MODULE_VERSION ("V3.00");
MODULE_AUTHOR("anhui egret electronic company");
MODULE_DESCRIPTION("module driver of if");
